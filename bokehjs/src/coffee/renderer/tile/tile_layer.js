// Generated by CoffeeScript 1.9.3
(function() {
  var Glyph, Helpers, ImagePool, MercatorTileSource, ProjectionUtils, QUADKEYTileSource, TMSTileSource, TileLayer, TileLayerView, TileSource, WMTSTileSource, _, logger,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require("underscore");

  Glyph = require("../glyph/glyph");

  logger = require("../../common/logging").logger;

  ImagePool = (function() {
    function ImagePool() {
      this.images = [];
    }

    ImagePool.prototype.pop = function() {
      var img;
      img = this.images.pop();
      if (img != null) {
        return img;
      } else {
        return new Image();
      }
    };

    ImagePool.prototype.push = function(img) {
      if (this.images.length > 50) {
        return;
      }
      if (img.constructor === Array) {
        return Array.prototype.push.apply(this.images, img);
      } else {
        return this.images.push(img);
      }
    };

    return ImagePool;

  })();

  ProjectionUtils = (function() {
    function ProjectionUtils() {
      this.origin_shift = 2 * Math.PI * 6378137 / 2.0;
    }

    ProjectionUtils.prototype.geographic_to_meters = function(xLon, yLat) {
      var mx, my;
      mx = xLon * this.origin_shift / 180.0;
      my = Math.log(Math.tan((90 + yLat) * Math.PI / 360.0)) / (Math.PI / 180.0);
      my = my * this.origin_shift / 180.0;
      return [mx, my];
    };

    ProjectionUtils.prototype.meters_to_geographic = function(mx, my) {
      var lat, lon;
      lon = (mx / this.origin_shift) * 180.0;
      lat = (my / this.origin_shift) * 180.0;
      lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180.0)) - Math.PI / 2.0);
      return [lon, lat];
    };

    ProjectionUtils.prototype.geographic_extent_to_meters = function(extent) {
      var ref, ref1, xmax, xmin, ymax, ymin;
      xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
      ref = this.geographic_to_meters(xmin, ymin), xmin = ref[0], ymin = ref[1];
      ref1 = this.geographic_to_meters(xmax, ymax), xmax = ref1[0], ymax = ref1[1];
      return [xmin, ymin, xmax, ymax];
    };

    ProjectionUtils.prototype.meters_extent_to_geographic = function(extent) {
      var ref, ref1, xmax, xmin, ymax, ymin;
      xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
      ref = this.meters_to_geographic(xmin, ymin), xmin = ref[0], ymin = ref[1];
      ref1 = this.meters_to_geographic(xmax, ymax), xmax = ref1[0], ymax = ref1[1];
      return [xmin, ymin, xmax, ymax];
    };

    return ProjectionUtils;

  })();

  Helpers = (function() {
    function Helpers() {}

    Helpers.string_lookup_replace = function(str, lookup) {
      var key, result_str, value;
      result_str = str;
      for (key in lookup) {
        value = lookup[key];
        result_str = result_str.replace('{' + key + '}', value.toString());
      }
      return result_str;
    };

    return Helpers;

  })();

  TileSource = (function() {
    function TileSource(options) {
      var ref, ref1, ref2;
      if (options == null) {
        options = {};
      }
      this.url = (ref = options.url) != null ? ref : '';
      this.tile_size = (ref1 = options.tile_size) != null ? ref1 : 256;
      this.extra_url_vars = (ref2 = options.extra_url_vars) != null ? ref2 : {};
      this.full_extent = options.full_extent;
      this.x_origin_offset = options.x_origin_offset;
      this.y_origin_offset = options.y_origin_offset;
      this.initial_resolution = options.initial_resolution;
      this.utils = new ProjectionUtils();
      this.pool = new ImagePool();
      this.tiles = {};
      this.max_zoom = 0;
      this.min_zoom = 30;
    }

    TileSource.prototype.update = function() {
      var key, ref, results, tile;
      logger.info("Tile Cache Count: " + Object.keys(this.tiles).length.toString());
      logger.info("X_ORIGIN_OFFSET: " + this.x_origin_offset.toString());
      logger.info("Y_ORIGIN_OFFSET: " + this.y_origin_offset.toString());
      ref = this.tiles;
      results = [];
      for (key in ref) {
        tile = ref[key];
        tile.current = false;
        results.push(tile.retain = false);
      }
      return results;
    };

    TileSource.prototype.tile_xyz_to_key = function(x, y, z) {
      var key;
      key = x + ":" + y + ":" + z;
      return key;
    };

    TileSource.prototype.key_to_tile_xyz = function(key) {
      var c;
      return (function() {
        var j, len, ref, results;
        ref = key.split(':');
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(parseInt(c));
        }
        return results;
      })();
    };

    TileSource.prototype.sort_tiles_from_center = function(tiles, tile_extent) {
      var center_x, center_y, txmax, txmin, tymax, tymin;
      txmin = tile_extent[0], tymin = tile_extent[1], txmax = tile_extent[2], tymax = tile_extent[3];
      center_x = (txmax - txmin) / 2 + txmin;
      center_y = (tymax - tymin) / 2 + tymin;
      tiles.sort(function(a, b) {
        var a_distance, b_distance;
        a_distance = Math.sqrt(Math.pow(center_x - a[0], 2) + Math.pow(center_y - a[1], 2));
        b_distance = Math.sqrt(Math.pow(center_x - b[0], 2) + Math.pow(center_y - b[1], 2));
        return a_distance - b_distance;
      });
      return tiles;
    };

    TileSource.prototype.prune_tiles = function() {
      var key, ref, ref1, results, tile;
      ref = this.tiles;
      for (key in ref) {
        tile = ref[key];
        tile.retain = tile.current || tile.tile_coords[2] < 3;
        if (tile.current) {
          this.retain_neighbors(tile);
          this.retain_children(tile);
          this.retain_parents(tile);
        }
      }
      ref1 = this.tiles;
      results = [];
      for (key in ref1) {
        tile = ref1[key];
        if (!tile.retain) {
          results.push(this.remove_tile(key));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    TileSource.prototype.remove_tile = function(key) {
      var tile;
      tile = this.tiles[key];
      if (tile != null) {
        this.pool.push(tile.img);
        return delete this.tiles[key];
      }
    };

    TileSource.prototype.get_image_url = function(x, y, z) {
      var image_url;
      image_url = Helpers.string_lookup_replace(this.url, this.extra_url_vars);
      return image_url.replace("{X}", x).replace('{Y}', y).replace("{Z}", z);
    };

    TileSource.prototype.retain_neighbors = function(reference_tile) {
      throw Error("Not Implemented");
    };

    TileSource.prototype.retain_parents = function(reference_tile) {
      throw Error("Not Implemented");
    };

    TileSource.prototype.retain_children = function(reference_tile) {
      throw Error("Not Implemented");
    };

    TileSource.prototype.tile_xyz_to_quadkey = function(x, y, z) {
      return "Not Implemented";
    };

    TileSource.prototype.quadkey_to_tile_xyz = function(quadkey) {
      return "Not Implemented";
    };

    return TileSource;

  })();

  MercatorTileSource = (function(superClass) {
    extend(MercatorTileSource, superClass);

    function MercatorTileSource() {
      var ref, ref1, ref2, ref3, ref4, z;
      MercatorTileSource.__super__.constructor.apply(this, arguments);
      this.full_extent = (ref = this.full_extent) != null ? ref : [-20037508.34, -20037508.34, 20037508.34, 20037508.34];
      this.x_origin_offset = (ref1 = this.x_origin_offset) != null ? ref1 : 20037508.34;
      this.y_origin_offset = (ref2 = this.y_origin_offset) != null ? ref2 : 20037508.34;
      this.initial_resolution = (ref3 = this.initial_resolution) != null ? ref3 : 2 * Math.PI * 6378137 / this.tile_size;
      this.resolutions = (ref4 = this.resolutions) != null ? ref4 : (function() {
        var j, results;
        results = [];
        for (z = j = 0; j <= 30; z = ++j) {
          results.push(this.get_resolution(z));
        }
        return results;
      }).call(this);
    }

    MercatorTileSource.prototype.retain_children = function(reference_tile) {
      var key, max_zoom, min_zoom, quadkey, ref, results, tile;
      quadkey = reference_tile.quadkey;
      min_zoom = quadkey.length;
      max_zoom = min_zoom + 3;
      ref = this.tiles;
      results = [];
      for (key in ref) {
        tile = ref[key];
        if (tile.quadkey.indexOf(quadkey) === 0 && tile.quadkey.length > min_zoom && tile.quadkey.length <= max_zoom) {
          results.push(tile.retain = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    MercatorTileSource.prototype.retain_neighbors = function(reference_tile) {
      var key, neighbor_radius, neighbor_x, neighbor_y, ref, ref1, results, tile, tx, ty, tz, x, y;
      neighbor_radius = 4;
      ref = reference_tile.tile_coords, tx = ref[0], ty = ref[1], tz = ref[2];
      neighbor_x = (function() {
        var j, ref1, ref2, results;
        results = [];
        for (x = j = ref1 = tx - neighbor_radius, ref2 = tx + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; x = ref1 <= ref2 ? ++j : --j) {
          results.push(x);
        }
        return results;
      })();
      neighbor_y = (function() {
        var j, ref1, ref2, results;
        results = [];
        for (y = j = ref1 = ty - neighbor_radius, ref2 = ty + neighbor_radius; ref1 <= ref2 ? j <= ref2 : j >= ref2; y = ref1 <= ref2 ? ++j : --j) {
          results.push(y);
        }
        return results;
      })();
      ref1 = this.tiles;
      results = [];
      for (key in ref1) {
        tile = ref1[key];
        if (tile.tile_coords[2] === tz && _.contains(neighbor_x, tile.tile_coords[0]) && _.contains(neighbor_y, tile.tile_coords[1])) {
          results.push(tile.retain = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    MercatorTileSource.prototype.retain_parents = function(reference_tile) {
      var key, quadkey, ref, results, tile;
      quadkey = reference_tile.quadkey;
      ref = this.tiles;
      results = [];
      for (key in ref) {
        tile = ref[key];
        results.push(tile.retain = quadkey.indexOf(tile.quadkey) === 0);
      }
      return results;
    };

    MercatorTileSource.prototype.children_by_tile_xyz = function(x, y, z) {
      var b, child_tile_xyz, i, j, quad_key, ref;
      quad_key = this.tile_xyz_to_quadkey(x, y, z);
      child_tile_xyz = [];
      for (i = j = 0; j <= 3; i = j += 1) {
        ref = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref[0], y = ref[1], z = ref[2];
        b = this.get_tile_meter_bounds(x, y, z);
        if (b != null) {
          child_tile_xyz.push([x, y, z, b]);
        }
      }
      return child_tile_xyz;
    };

    MercatorTileSource.prototype.parent_by_tile_xyz = function(x, y, z) {
      var parent_quad_key, quad_key;
      quad_key = this.tile_xyz_to_quadkey(x, y, z);
      parent_quad_key = quad_key.substring(0, quad_key.length - 1);
      return this.quadkey_to_tile_xyz(parent_quad_key);
    };

    MercatorTileSource.prototype.get_resolution = function(level) {
      return this.initial_resolution / Math.pow(2, level);
    };

    MercatorTileSource.prototype.get_resolution_by_extent = function(extent, height, width) {
      var x_rs, y_rs;
      x_rs = (extent[2] - extent[0]) / width;
      y_rs = (extent[3] - extent[1]) / height;
      return [x_rs, y_rs];
    };

    MercatorTileSource.prototype.get_level_by_extent = function(extent, height, width) {
      var i, j, len, r, ref, resolution, x_rs, y_rs;
      x_rs = (extent[2] - extent[0]) / width;
      y_rs = (extent[3] - extent[1]) / height;
      resolution = Math.max(x_rs, y_rs);
      i = 0;
      ref = this.resolutions;
      for (j = 0, len = ref.length; j < len; j++) {
        r = ref[j];
        if (resolution > r) {
          if (i === 0) {
            return 0;
          }
          if (i > 0) {
            return i - 1;
          }
        }
        i += 1;
      }
    };

    MercatorTileSource.prototype.get_closest_level_by_extent = function(extent, height, width) {
      var closest, resolution, x_rs, y_rs;
      x_rs = (extent[2] - extent[0]) / width;
      y_rs = (extent[3] - extent[1]) / height;
      resolution = Math.max(x_rs, y_rs);
      closest = this.resolutions.reduce(function(previous, current) {
        if (Math.abs(current - resolution) < Math.abs(previous - resolution)) {
          return current;
        }
        return previous;
      });
      return this.resolutions.indexOf(closest);
    };

    MercatorTileSource.prototype.snap_to_zoom = function(extent, height, width, level) {
      var desired_res, desired_x_delta, desired_y_delta, x_adjust, xmax, xmin, y_adjust, ymax, ymin;
      desired_res = this.resolutions[level];
      desired_x_delta = width * desired_res;
      desired_y_delta = height * desired_res;
      xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
      x_adjust = (desired_x_delta - (xmax - xmin)) / 2;
      y_adjust = (desired_y_delta - (ymax - ymin)) / 2;
      return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];
    };

    MercatorTileSource.prototype.tms_to_wmts = function(x, y, z) {
      'Note this works both ways';
      return [x, Math.pow(2, z) - 1 - y, z];
    };

    MercatorTileSource.prototype.wmts_to_tms = function(x, y, z) {
      'Note this works both ways';
      return [x, Math.pow(2, z) - 1 - y, z];
    };

    MercatorTileSource.prototype.pixels_to_meters = function(px, py, level) {
      var mx, my, res;
      res = this.get_resolution(level);
      mx = px * res - this.x_origin_offset;
      my = py * res - this.y_origin_offset;
      return [mx, my];
    };

    MercatorTileSource.prototype.meters_to_pixels = function(mx, my, level) {
      var px, py, res;
      res = this.get_resolution(level);
      px = (mx + this.x_origin_offset) / res;
      py = (my + this.y_origin_offset) / res;
      return [px, py];
    };

    MercatorTileSource.prototype.pixels_to_tile = function(px, py) {
      var tx, ty;
      tx = Math.max(Math.ceil(px / parseFloat(this.tile_size)) - 1, 0);
      ty = Math.max(Math.ceil(py / parseFloat(this.tile_size)) - 1, 0);
      return [tx, ty];
    };

    MercatorTileSource.prototype.pixels_to_raster = function(px, py, level) {
      var mapSize;
      mapSize = this.tile_size << level;
      return [px, mapSize - py];
    };

    MercatorTileSource.prototype.meters_to_tile = function(mx, my, level) {
      var px, py, ref;
      ref = this.meters_to_pixels(mx, my, level), px = ref[0], py = ref[1];
      return this.pixels_to_tile(px, py);
    };

    MercatorTileSource.prototype.get_tile_meter_bounds = function(tx, ty, level) {
      var ref, ref1, xmax, xmin, ymax, ymin;
      ref = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level), xmin = ref[0], ymin = ref[1];
      ref1 = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level), xmax = ref1[0], ymax = ref1[1];
      if ((xmin != null) && (ymin != null) && (xmax != null) && (ymax != null)) {
        return [xmin, ymin, xmax, ymax];
      } else {
        return void 0;
      }
    };

    MercatorTileSource.prototype.get_tile_geographic_bounds = function(tx, ty, level) {
      var bounds, maxLat, maxLon, minLat, minLon, ref;
      bounds = this.get_tile_meter_bounds(tx, ty, level);
      ref = this.utils.meters_extent_to_geographic(bounds), minLon = ref[0], minLat = ref[1], maxLon = ref[2], maxLat = ref[3];
      return [minLon, minLat, maxLon, maxLat];
    };

    MercatorTileSource.prototype.get_tiles_by_extent = function(extent, level, tile_border) {
      var j, k, ref, ref1, ref2, ref3, ref4, ref5, tiles, tx, txmax, txmin, ty, tymax, tymin, xmax, xmin, ymax, ymin;
      if (tile_border == null) {
        tile_border = 1;
      }
      xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
      ref = this.meters_to_tile(xmin, ymin, level), txmin = ref[0], tymin = ref[1];
      ref1 = this.meters_to_tile(xmax, ymax, level), txmax = ref1[0], tymax = ref1[1];
      txmin -= tile_border;
      tymin -= tile_border;
      txmax += tile_border;
      tymax += tile_border;
      tiles = [];
      for (ty = j = ref2 = tymax, ref3 = tymin; j >= ref3; ty = j += -1) {
        for (tx = k = ref4 = txmin, ref5 = txmax; k <= ref5; tx = k += 1) {
          tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);
          tiles = this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);
        }
      }
      return tiles;
    };

    MercatorTileSource.prototype.quadkey_to_tile_xyz = function(quadKey) {
      'Computes tile x, y and z values based on quadKey.';
      var i, j, mask, ref, tileX, tileY, tileZ, value;
      tileX = 0;
      tileY = 0;
      tileZ = quadKey.length;
      for (i = j = ref = tileZ; j > 0; i = j += -1) {
        value = quadKey.charAt(tileZ - i);
        mask = 1 << (i - 1);
        if (value === '0') {
          continue;
        } else if (value === '1') {
          tileX |= mask;
        } else if (value === '2') {
          tileY |= mask;
        } else if (value === '3') {
          tileX |= mask;
          tileY |= mask;
        } else {
          throw new TypeError("Invalid Quadkey: " + quadKey);
        }
      }
      return [tileX, tileY, tileZ];
    };

    MercatorTileSource.prototype.tile_xyz_to_quadkey = function(x, y, z) {
      'Computes quadkey value based on tile x, y and z values.';
      var digit, i, j, mask, quadKey, ref;
      quadKey = '';
      for (i = j = ref = z; j > 0; i = j += -1) {
        digit = 0;
        mask = 1 << (i - 1);
        if ((x & mask) !== 0) {
          digit += 1;
        }
        if ((y & mask) !== 0) {
          digit += 2;
        }
        quadKey += digit.toString();
      }
      return quadKey;
    };

    MercatorTileSource.prototype.children_by_tile_xyz = function(x, y, z) {
      var b, child_tile_xyz, i, j, quad_key, ref;
      quad_key = this.tile_xyz_to_quadkey(x, y, z);
      child_tile_xyz = [];
      for (i = j = 0; j <= 3; i = j += 1) {
        ref = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = ref[0], y = ref[1], z = ref[2];
        b = this.get_tile_meter_bounds(x, y, z);
        if (b != null) {
          child_tile_xyz.push([x, y, z, b]);
        }
      }
      return child_tile_xyz;
    };

    MercatorTileSource.prototype.parent_by_tile_xyz = function(x, y, z) {
      var parent_quad_key, quad_key;
      quad_key = this.tile_xyz_to_quadkey(x, y, z);
      parent_quad_key = quad_key.substring(0, quad_key.length - 1);
      return this.quadkey_to_tile_xyz(parent_quad_key);
    };

    MercatorTileSource.prototype.get_closest_parent_by_tile_xyz = function(x, y, z) {
      var quad_key, ref;
      quad_key = this.tile_xyz_to_quadkey(x, y, z);
      while (quad_key.length > 0) {
        quad_key = quad_key.substring(0, quad_key.length - 1);
        ref = this.quadkey_to_tile_xyz(quad_key), x = ref[0], y = ref[1], z = ref[2];
        if (this.tile_xyz_to_key(x, y, z) in this.tiles) {
          return [x, y, z];
        }
      }
      return [0, 0, 0];
    };

    return MercatorTileSource;

  })(TileSource);

  TMSTileSource = (function(superClass) {
    extend(TMSTileSource, superClass);

    function TMSTileSource() {
      return TMSTileSource.__super__.constructor.apply(this, arguments);
    }

    TMSTileSource.prototype.get_image_url = function(x, y, z) {
      var image_url;
      image_url = Helpers.string_lookup_replace(this.url, this.extra_url_vars);
      return image_url.replace("{X}", x).replace('{Y}', y).replace("{Z}", z);
    };

    return TMSTileSource;

  })(MercatorTileSource);

  WMTSTileSource = (function(superClass) {
    extend(WMTSTileSource, superClass);

    function WMTSTileSource() {
      return WMTSTileSource.__super__.constructor.apply(this, arguments);
    }

    WMTSTileSource.prototype.get_image_url = function(x, y, z) {
      var image_url, ref;
      image_url = Helpers.string_lookup_replace(this.url, this.extra_url_vars);
      ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];
      return image_url.replace("{X}", x).replace('{Y}', y).replace("{Z}", z);
    };

    return WMTSTileSource;

  })(MercatorTileSource);

  QUADKEYTileSource = (function(superClass) {
    extend(QUADKEYTileSource, superClass);

    function QUADKEYTileSource() {
      return QUADKEYTileSource.__super__.constructor.apply(this, arguments);
    }

    QUADKEYTileSource.prototype.get_image_url = function(x, y, z) {
      var image_url, quadKey, ref;
      image_url = Helpers.string_lookup_replace(this.url, this.extra_url_vars);
      ref = this.tms_to_wmts(x, y, z), x = ref[0], y = ref[1], z = ref[2];
      quadKey = this.tile_xyz_to_quadkey(x, y, z);
      return image_url.replace("{Q}", quadKey);
    };

    return QUADKEYTileSource;

  })(MercatorTileSource);

  TileLayerView = (function(superClass) {
    extend(TileLayerView, superClass);

    function TileLayerView() {
      this._update = bind(this._update, this);
      this._prefetch_tiles = bind(this._prefetch_tiles, this);
      this._on_tile_error = bind(this._on_tile_error, this);
      this._on_tile_cache_load = bind(this._on_tile_cache_load, this);
      this._on_tile_load = bind(this._on_tile_load, this);
      this._doubletap = bind(this._doubletap, this);
      return TileLayerView.__super__.constructor.apply(this, arguments);
    }

    TileLayerView.prototype.trace = function(msg) {
      return console.warn("TileLayerView :: " + msg.toString());
    };

    TileLayerView.prototype.get_extent = function() {
      return [this.x_range.get('start'), this.y_range.get('start'), this.x_range.get('end'), this.y_range.get('end')];
    };

    TileLayerView.prototype._doubletap = function(e) {
      var extent, new_extent, new_resolution, new_xrange, new_yrange, nxmax, nxmin, nymax, nymin, x_percent, xmax, xmin, y_percent, ymax, ymin, zoom_level;
      extent = this.get_extent();
      xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
      x_percent = (e.bokeh.plot_x - xmin) / (xmax - xmin);
      y_percent = (e.bokeh.plot_y - ymin) / (ymax - ymin);
      zoom_level = this.tile_source.get_closest_level_by_extent(extent, this.map_frame.get('height'), this.map_frame.get('width'));
      if (e.srcEvent.shiftKey) {
        zoom_level = zoom_level - 1;
      } else {
        zoom_level = zoom_level + 1;
      }
      new_resolution = this.tile_source.resolutions[zoom_level];
      new_xrange = new_resolution * this.map_frame.get('width');
      new_yrange = new_resolution * this.map_frame.get('height');
      nxmin = e.bokeh.plot_x - (x_percent * new_xrange);
      nymin = e.bokeh.plot_y - (y_percent * new_yrange);
      nxmax = xmin + new_xrange;
      nymax = ymin + new_yrange;
      new_extent = this.tile_source.snap_to_zoom([nxmin, nymin, nxmax, nymax], this.map_frame.get('height'), this.map_frame.get('width'), zoom_level);
      this.x_range.set('start', new_extent[0]);
      this.y_range.set('start', new_extent[1]);
      this.x_range.set('end', new_extent[2]);
      return this.y_range.set('end', new_extent[3]);
    };

    TileLayerView.prototype._create_tile_source = function() {
      var tile_options;
      tile_options = {
        url: this.mget('url'),
        tile_size: this.mget('tile_size'),
        x_origin_offset: this.mget('x_origin_offset'),
        y_origin_offset: this.mget('y_origin_offset'),
        extra_url_vars: this.mget('extra_url_vars'),
        initial_resolution: this.mget('initial_resolution')
      };
      if (source_type.toLowerCase() === 'quadkeytilesource') {
        return new QUADKEYTileSource(tile_options);
      }
      if (source_type.toLowerCase() === 'tmstilesource') {
        return new TMSTileSource(tile_options);
      }
      if (source_type.toLowerCase() === 'wmtstilesource') {
        return new WMTSTileSource(tile_options);
      }
      throw Error("Source Type " + source_type + " not among valid tile source types (e.g. QUADKEYTileSource, TMSTileSource, WMTSTileSource)");
    };

    TileLayerView.prototype._index_data = function() {
      return this._xy_index();
    };

    TileLayerView.prototype._set_data = function() {
      this.tile_source = this._create_tile_source();
      this.pool = new ImagePool();
      this.map_plot = this.renderer.plot_view.model;
      this.map_canvas = this.renderer.plot_view.canvas_view.ctx;
      this.map_frame = this.renderer.plot_view.frame;
      this.x_range = this.map_plot.get('x_range');
      this.x_mapper = this.map_frame.get('x_mappers')['default'];
      this.y_range = this.map_plot.get('y_range');
      this.y_mapper = this.map_frame.get('y_mappers')['default'];
      return this.renderer.listenTo(this.renderer, 'doubletap', this._doubletap);
    };

    TileLayerView.prototype._map_data = function() {
      var new_extent, zoom_level;
      if (this.map_initialized == null) {
        this.initial_extent = this.get_extent();
        zoom_level = this.tile_source.get_level_by_extent(this.initial_extent, this.map_frame.get('height'), this.map_frame.get('width'));
        new_extent = this.tile_source.snap_to_zoom(this.initial_extent, this.map_frame.get('height'), this.map_frame.get('width'), zoom_level);
        this.x_range.set('start', new_extent[0]);
        this.y_range.set('start', new_extent[1]);
        this.x_range.set('end', new_extent[2]);
        this.y_range.set('end', new_extent[3]);
        return this.map_initialized = true;
      }
    };

    TileLayerView.prototype._on_tile_load = function(e) {
      var tile_data;
      tile_data = e.target.tile_data;
      tile_data.img = e.target;
      tile_data.current = true;
      this._render_tile(tile_data.cache_key);
      return this.tile_source.tiles[tile_data.cache_key] = tile_data;
    };

    TileLayerView.prototype._on_tile_cache_load = function(e) {
      var tile_data;
      tile_data = e.target.tile_data;
      tile_data.img = e.target;
      return this.tile_source.tiles[tile_data.cache_key] = tile_data;
    };

    TileLayerView.prototype._on_tile_error = function(e) {
      return '';
    };

    TileLayerView.prototype._is_valid_tile = function(x, y, z) {
      if (y < 0 || y > 1 << z || x < 0 || x > 1 << z) {
        return false;
      }
      return true;
    };

    TileLayerView.prototype._create_tile = function(x, y, z, bounds, cache_only) {
      var tile;
      if (cache_only == null) {
        cache_only = false;
      }
      tile = this.pool.pop();
      if (cache_only) {
        tile.onload = this._on_tile_cache_load;
      } else {
        tile.onload = this._on_tile_load;
      }
      tile.onerror = this._on_tile_error;
      tile.alt = '';
      tile.tile_data = {
        tile_coords: [x, y, z],
        quadkey: this.tile_source.tile_xyz_to_quadkey(x, y, z),
        cache_key: this.tile_source.tile_xyz_to_key(x, y, z),
        bounds: bounds,
        x_coord: bounds[0],
        y_coord: bounds[3]
      };
      tile.src = this.tile_source.get_image_url(x, y, z);
      return tile;
    };

    TileLayerView.prototype._render = function(ctx, indices, arg) {
      var abridged, angle, image, need_load, sh, sw, sx, sy, url;
      url = arg.url, image = arg.image, need_load = arg.need_load, sx = arg.sx, sy = arg.sy, sw = arg.sw, sh = arg.sh, angle = arg.angle;
      this._update(abridged = true);
      if (this.render_timer != null) {
        clearTimeout(this.render_timer);
      }
      if (this.prefetch_timer != null) {
        clearTimeout(this.prefetch_timer);
      }
      this.render_timer = setTimeout(this._update, 65);
      return this.prefetch_timer = setTimeout(this._prefetch_tiles, 500);
    };

    TileLayerView.prototype._draw_tile = function(tile_key) {
      var ref, ref1, sh, sw, sx, sxmax, sxmin, sy, symax, symin, tile_obj;
      tile_obj = this.tile_source.tiles[tile_key];
      if (tile_obj != null) {
        ref = this.renderer.plot_view.frame.map_to_screen([tile_obj.bounds[0]], [tile_obj.bounds[3]], this.renderer.plot_view.canvas), sxmin = ref[0], symin = ref[1];
        ref1 = this.renderer.plot_view.frame.map_to_screen([tile_obj.bounds[2]], [tile_obj.bounds[1]], this.renderer.plot_view.canvas), sxmax = ref1[0], symax = ref1[1];
        sxmin = sxmin[0];
        symin = symin[0];
        sxmax = sxmax[0];
        symax = symax[0];
        sw = sxmax - sxmin;
        sh = symax - symin;
        sx = sxmin;
        sy = symin;
        return this.map_canvas.drawImage(tile_obj.img, sx, sy, sw, sh);
      }
    };

    TileLayerView.prototype._render_tile = function(tile_key) {
      this.map_canvas.save();
      this.map_canvas.rect(this.map_frame.get('left') + 1, this.map_frame.get('bottom') + 2, this.map_frame.get('width') - 2, this.map_frame.get('height'));
      this.map_canvas.clip();
      this._draw_tile(tile_key);
      return this.map_canvas.restore();
    };

    TileLayerView.prototype._render_tiles = function(tile_keys) {
      var j, len, tile_key;
      this.map_canvas.save();
      this.map_canvas.rect(this.map_frame.get('left') + 1, this.map_frame.get('bottom') + 2, this.map_frame.get('width') - 2, this.map_frame.get('height'));
      this.map_canvas.clip();
      for (j = 0, len = tile_keys.length; j < len; j++) {
        tile_key = tile_keys[j];
        this._draw_tile(tile_key);
      }
      return this.map_canvas.restore();
    };

    TileLayerView.prototype._prefetch_tiles = function() {
      var bounds, c, cbounds, children, cx, cy, cz, extent, j, ref, results, t, tiles, x, y, z, zoom_level;
      extent = this.get_extent();
      zoom_level = this.tile_source.get_level_by_extent(extent, this.map_frame.get('height'), this.map_frame.get('width'));
      tiles = this.tile_source.get_tiles_by_extent(extent, zoom_level);
      results = [];
      for (t = j = 0, ref = Math.min(10, tiles.length); j <= ref; t = j += 1) {
        x = t[0], y = t[1], z = t[2], bounds = t[3];
        children = this.tile_source.children_by_tile_xyz(x, y, z);
        results.push((function() {
          var k, len, results1;
          results1 = [];
          for (k = 0, len = children.length; k < len; k++) {
            c = children[k];
            cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];
            if (this.tile_source.tile_xyz_to_key(cx, cy, cz) in this.tile_source.tiles) {
              continue;
            } else {
              results1.push(this._create_tile(cx, cy, cz, cbounds, true));
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    TileLayerView.prototype._update = function(abridged) {
      var bounds, cached, extent, j, k, key, l, len, len1, len2, need_load, parent_key, parents, px, py, pz, ref, results, t, tiles, x, y, z, zoom_level;
      if (abridged == null) {
        abridged = false;
      }
      this.tile_source.update();
      extent = this.get_extent();
      zoom_level = this.tile_source.get_level_by_extent(extent, this.map_frame.get('height'), this.map_frame.get('width'));
      tiles = this.tile_source.get_tiles_by_extent(extent, zoom_level);
      parents = [];
      need_load = [];
      cached = [];
      for (j = 0, len = tiles.length; j < len; j++) {
        t = tiles[j];
        x = t[0], y = t[1], z = t[2], bounds = t[3];
        if (this._is_valid_tile(x, y, z)) {
          key = this.tile_source.tile_xyz_to_key(x, y, z);
          if (key in this.tile_source.tiles) {
            cached.push(key);
          } else {
            ref = this.tile_source.get_closest_parent_by_tile_xyz(x, y, z), px = ref[0], py = ref[1], pz = ref[2];
            parent_key = this.tile_source.tile_xyz_to_key(px, py, pz);
            if (parent_key in this.tile_source.tiles) {
              parents.push(parent_key);
            }
            need_load.push(t);
          }
        }
      }
      this._render_tiles(parents);
      if (!abridged) {
        for (k = 0, len1 = need_load.length; k < len1; k++) {
          t = need_load[k];
          x = t[0], y = t[1], z = t[2], bounds = t[3];
          this._create_tile(x, y, z, bounds);
        }
      }
      this._render_tiles(cached);
      results = [];
      for (l = 0, len2 = cached.length; l < len2; l++) {
        t = cached[l];
        results.push(this.tile_source.tiles[t].current = true);
      }
      return results;
    };

    return TileLayerView;

  })(Glyph.View);

  TileLayer = (function(superClass) {
    extend(TileLayer, superClass);

    function TileLayer() {
      return TileLayer.__super__.constructor.apply(this, arguments);
    }

    TileLayer.prototype.default_view = TileLayerView;

    TileLayer.prototype.type = 'TileLayer';

    TileLayer.prototype.visuals = [];

    TileLayer.prototype.distances = ['w', 'h'];

    TileLayer.prototype.angles = ['angle'];

    TileLayer.prototype.defaults = function() {
      return _.extend({}, TileLayer.__super__.defaults.call(this), {
        angle: 0,
        global_alpha: 1.0
      });
    };

    TileLayer.prototype.display_defaults = function() {
      return _.extend({}, TileLayer.__super__.display_defaults.call(this), {
        tile_source: "WMTSTileSource",
        url: "http://c.tile.openstreetmap.org/{Z}/{X}/{Y}.png",
        tile_size: 256,
        min_zoom: 0,
        max_zoom: 30,
        x_origin_offset: 20037508.34,
        y_origin_offset: 20037508.34,
        extra_url_vars: {},
        initial_resolution: 2 * Math.PI * 6378137 / 256
      });
    };

    return TileLayer;

  })(Glyph.Model);

  module.exports = {
    Model: TileLayer,
    View: TileLayerView,
    TileSource: TileSource,
    ProjectionUtils: ProjectionUtils,
    MercatorTileSource: MercatorTileSource,
    TMSTileSource: TMSTileSource,
    WMTSTileSource: WMTSTileSource,
    QUADKEYTileSource: QUADKEYTileSource
  };

}).call(this);
